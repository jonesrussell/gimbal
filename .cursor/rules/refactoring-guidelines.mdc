# Refactoring Guidelines - MINIMAL FIX APPROACH

## Core Principles
- **Focused fixes** for specific problems, not massive rewrites
- **No breaking changes** to working code
- **Incremental improvement** instead of revolution
- **Easy to test** and verify each step
- **Low risk** of introducing new bugs

## When Refactoring
1. **STOP aggressive rewrites** - they create more problems than they solve
2. **Use minimal interfaces** - create specific interfaces only where needed
3. **Preserve working code** - don't rewrite systems that already work
4. **Test after each change** - run `task build` to ensure progress
5. **Clean up remnants** - remove duplicates and fix conflicts from previous attempts

## Interface{} Anti-Pattern Fix
- **Create minimal interfaces** in the package that needs them
- **Don't create new packages** for simple interface definitions
- **Use wrapper methods** to adapt existing systems to new interfaces
- **Keep interfaces small** - only the methods actually needed

## Context Usage
- **Add context gradually** - start with resource loading only
- **Don't force context everywhere** - only where it provides real value
- **Use context.Background()** for existing code that doesn't need cancellation

## Success Criteria
- [ ] **ZERO** new packages created
- [ ] **ZERO** import cycles
- [ ] **Game still runs** exactly the same
- [ ] **Only interface{}** replaced with type-safe interfaces
- [ ] **Context added** only where it matters
- [ ] **Build passes**: `task build && task lint`
- [ ] **Diff is small** - dozens of lines, not hundreds

## Example: Minimal Interface Fix
```go
// BEFORE (problematic)
type CollisionSystemConfig struct {
    HealthSystem interface{} // Type-unsafe
}

// AFTER (minimal fix)
type HealthSystemInterface interface {
    DamagePlayer(entity donburi.Entity, damage int)
}

type CollisionSystemConfig struct {
    HealthSystem HealthSystemInterface // Type-safe
}
```

## Anti-Patterns to Avoid
- **Creating adapter packages** - use wrapper methods instead
- **Rewriting working systems** - only fix what's broken
- **Adding context everywhere** - only where it provides value
- **Breaking existing APIs** - maintain backward compatibility
- **Over-engineering simple problems** - keep solutions simple
